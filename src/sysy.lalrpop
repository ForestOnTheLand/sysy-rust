use crate::ast::*;

grammar;

match {
    // Skip Whitespace
    r"\s*" => {},
    // Skip Comment - Single-line
    r"//[^\n\r]*[\n\r]*" => {},
    // Skip Comment - Multi-line
    r"/\*([^*]|\*+[^/]+)*\*+/" => {},
    // Default
    _
}

Comma<T>: Vec<T> = <mut v: (<T> ",")*> <e: T> => {
    v.push(e);
    v
};

// CompUnit ::= (Decl | FuncDef) [CompUnit];
pub CompUnit: Box<CompUnit> = {
    <func_def: FuncDef> <comp_unit: CompUnit?> => Box::new(CompUnit { comp_unit, item: Box::new(GlobalItem::FuncDef(func_def)) }),
    <decl: Decl> <comp_unit: CompUnit?> => Box::new(CompUnit { comp_unit, item: Box::new(GlobalItem::Decl(decl)) }),
}

// FuncDef     ::= BuiltinType IDENT "(" [FuncFParams] ")" Block;
FuncDef: Box<FuncDef> = {
    <func_type: BuiltinType> <ident: Ident> "(" <params: FuncFParams?> ")" <block: Block> => {
        Box::new(FuncDef { <> })
    }
}

// BuiltinType    ::= "void" | "int";
BuiltinType: BuiltinType = {
    "void" => BuiltinType::Void,
    "int" => BuiltinType::Int,
}

// FuncFParams ::= FuncFParam {"," FuncFParam}
FuncFParams: FuncFParams = <params: Comma<FuncFParam>> => FuncFParams{ <> };

// FuncFParam  ::= BuiltinType IDENT;
FuncFParam: FuncFParam = <btype: BuiltinType> <ident: Ident> => FuncFParam{ <> };

// Block ::= "{" {BlockItem} "}";
Block: Block = "{" <block_items: BlockItem*> "}" => Block { <> };

// BlockItem ::= Decl | Stmt;
BlockItem: Box<BlockItem> = {
    Decl => Box::new(BlockItem::Decl( <> )),
    Stmt => Box::new(BlockItem::Stmt( <> )),
}

// Stmt ::= LVal "=" Exp ";"
//        | [Exp] ";"
//        | Block
//        | "if" "(" Exp ")" Stmt ["else" Stmt]
//        | "while" "(" Exp ")" Stmt
//        | "return" [Exp] ";";
Stmt: Box<Stmt> = {
    MatchedStmt => <>,
    OpenStmt => <>,
}

MatchedStmt: Box<Stmt> = {
    <LVal> "=" <Exp> ";" => Box::new(Stmt::Assign( <> )),
    <Exp?> ";" => Box::new(Stmt::Exp( <> )),
    "if" "(" <exp: Exp> ")" <s1: MatchedStmt> "else" <s2: MatchedStmt> => Box::new(Stmt::Condition(exp, s1, Some(s2))),
    <Block> => Box::new(Stmt::Block(Box::new( <> ))),
    "while" "(" <Exp> ")" <MatchedStmt> => Box::new(Stmt::While( <> )),
    "break" ";" => Box::new(Stmt::Break),
    "continue" ";" => Box::new(Stmt::Continue),
    "return" <exp: Exp?> ";" => Box::new(Stmt::Return( <> )), 
}

// Something that should have no trailing "else"
OpenStmt: Box<Stmt> = {
    "if" "(" <exp: Exp> ")" <s1: MatchedStmt> "else" <s2: OpenStmt> => Box::new(Stmt::Condition(exp, s1, Some(s2))),
    "if" "(" <exp: Exp> ")" <s1: Stmt> => Box::new(Stmt::Condition(exp, s1, None)),
    "while" "(" <Exp> ")" <OpenStmt> => Box::new(Stmt::While( <> )),
}

// Decl ::= ConstDecl | VarDecl;
Decl: Box<Decl> = {
    ConstDecl => Box::new(Decl::Const( <> )),
    VarDecl => Box::new(Decl::Var( <> )),
}
// VarDecl ::= BuiltinType VarDef {"," VarDef} ";";
VarDecl: Box<VarDecl> = <btype: BuiltinType> <var_defs: Comma<VarDef>> ";" => Box::new(VarDecl { <> });
// VarDef ::= IDENT | IDENT "=" InitVal;
VarDef: Box<VarDef> = {
    <ident: Ident> => Box::new(VarDef {ident, init_val: None} ),
    <ident: Ident> "=" <init_val: InitVal> => Box::new(VarDef {ident, init_val: Some(init_val)} ),
}
// InitVal ::= Exp;
InitVal: Box<InitVal> = <exp: Exp> => Box::new(InitVal { <> });

// ConstDecl ::= "const" BuiltinType ConstDef {"," ConstDef} ";";
ConstDecl: Box<ConstDecl> = "const" <btype: BuiltinType> <const_defs: Comma<ConstDef>> ";" => Box::new(ConstDecl { <> });
// BuiltinType ::= "int";
// BuiltinType: BuiltinType = "int" => BuiltinType::Int;
// ConstDef ::= IDENT "=" ConstInitVal;
ConstDef: Box<ConstDef> = <ident: Ident> "=" <const_init_val: ConstInitVal> => Box::new(ConstDef { <> });
// ConstInitVal ::= ConstExp;
ConstInitVal: Box<ConstInitVal> = <const_exp: ConstExp> => Box::new(ConstInitVal { <> });

// LVal ::= IDENT;
LVal: LVal = <ident: Ident> => LVal { <> };

// ConstExp ::= Exp;
ConstExp: Box<ConstExp> = <exp: Exp> => Box::new(ConstExp { <> });

// Exp ::= LOrExp;
Exp: Box<Exp> = <lor_exp: LOrExp> => Box::new(Exp { <> });
// PrimaryExp ::= "(" Exp ")" | LVal | Number;
PrimaryExp: Box<PrimaryExp> = {
    "(" <Exp> ")" => Box::new(PrimaryExp::Expression( <> )),
    LVal => Box::new(PrimaryExp::LVal( <> )),
    Number => Box::new(PrimaryExp::Number( <> )),
}
// UnaryExp ::= PrimaryExp | UnaryOp UnaryExp | IDENT "(" [FuncRParams] ")";
UnaryExp: Box<UnaryExp> = {
    PrimaryExp => Box::new(UnaryExp::Single( <> )),
    UnaryOp UnaryExp => Box::new(UnaryExp::Unary( <> )),
    <Ident> "(" <FuncRParams?> ")" => Box::new(UnaryExp::Call( <> )),
}
// FuncRParams ::= Exp {"," Exp}
FuncRParams: Box<FuncRParams> = <exps: Comma<Exp>> => Box::new(FuncRParams { <> });
// UnaryOp ::= "+" | "-" | "!";
UnaryOp: UnaryOp = {
    "+" => UnaryOp::Pos,
    "-" => UnaryOp::Neg,
    "!" => UnaryOp::Not,
}
// MulExp ::= UnaryExp | MulExp ("*" | "/" | "%") UnaryExp;
MulExp: Box<MulExp> = {
    UnaryExp => Box::new(MulExp::Single( <> )),
    MulExp MulOp UnaryExp => Box::new(MulExp::Binary( <> )),
}
MulOp: MulOp = {
    "*" => MulOp::Mul,
    "/" => MulOp::Div,
    "%" => MulOp::Mod,
}
// AddExp ::= MulExp | AddExp ("+" | "-") MulExp;
AddExp: Box<AddExp> = {
    MulExp => Box::new(AddExp::Single( <> )),
    AddExp AddOp MulExp => Box::new(AddExp::Binary( <> )),
}
AddOp: AddOp = {
    "+" => AddOp::Add,
    "-" => AddOp::Sub,
}
// RelExp ::= AddExp | RelExp ("<" | ">" | "<=" | ">=") AddExp;
RelExp: Box<RelExp> = {
    AddExp => Box::new(RelExp::Single( <> )),
    RelExp RelOp AddExp => Box::new(RelExp::Binary( <> )),
}
RelOp: RelOp = {
    "<" => RelOp::Lt,
    ">" => RelOp::Gt,
    "<=" => RelOp::Le,
    ">=" => RelOp::Ge,
}
// EqExp ::= RelExp | EqExp ("==" | "!=") RelExp;
EqExp: Box<EqExp> = {
    RelExp => Box::new(EqExp::Single( <> )),
    EqExp EqOp RelExp => Box::new(EqExp::Binary( <> )),
}
EqOp: EqOp = {
    "==" => EqOp::Eq,
    "!=" => EqOp::Neq,
}
// LAndExp ::= EqExp | LAndExp "&&" EqExp;
LAndExp: Box<LAndExp> = {
    EqExp => Box::new(LAndExp::Single( <> )),
    <LAndExp> "&&" <EqExp> => Box::new(LAndExp::Binary( <> )),
}
// LOrExp ::= LAndExp | LOrExp "||" LAndExp;
LOrExp: Box<LOrExp> = {
    LAndExp => Box::new(LOrExp::Single( <> )),
    <LOrExp> "||" <LAndExp> => Box::new(LOrExp::Binary( <> )),
}



Number: i32 = <num: IntConst> => <>;

Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();

IntConst: i32 = {
    r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
    r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
    r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
}
