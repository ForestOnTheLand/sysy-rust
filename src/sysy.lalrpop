use crate::ast::*;

grammar;

match {
    // Skip Whitespace
    r"\s*" => {},
    // Skip Comment - Single-line
    r"//[^\n\r]*[\n\r]*" => {},
    // Skip Comment - Multi-line
    r"/\*([^*]|(\*)*[^*/])*(\*)*\*/" => {},
    // Default
    _
}

Comma<T>: Vec<T> = <mut v: (<T> ",")*> <e: T> => {
    v.push(e);
    v
};

// CompUnit ::= (Decl | FuncDef) [CompUnit];
pub CompUnit: Box<CompUnit> = {
    <items: (<GlobalItem>)*> => Box::new(CompUnit { <> }),
}

GlobalItem: Box<GlobalItem> = {
    <FuncDef> => Box::new(GlobalItem::FuncDef( <> )),
    <GlobalDecl> => Box::new(GlobalItem::Decl( <> )),
}

GlobalDecl: Box<GlobalDecl> = {
    <ConstDecl> => Box::new(GlobalDecl::Const( <> )),
    <GlobalVarDecl> => Box::new(GlobalDecl::Var( <> )),
}

GlobalVarDecl: Box<GlobalVarDecl> = {
    <btype: BuiltinType> <var_defs: Comma<GlobalVarDef>> ";" => Box::new(GlobalVarDecl { <> }),
}

GlobalVarDef: Box<GlobalVarDef> = {
    <ident: Ident> <shape: ("[" <ConstExp> "]")*> <init_val: ("=" <ConstInitVal>)?> => Box::new(GlobalVarDef { <> }),
}

// FuncDef     ::= BuiltinType IDENT "(" [FuncFParams] ")" Block;
FuncDef: Box<FuncDef> = {
    <func_type: BuiltinType> <ident: Ident> "(" <params: FuncFParams?> ")" <block: Block> => {
        Box::new(FuncDef { <> })
    }
}

// BuiltinType    ::= "void" | "int";
BuiltinType: BuiltinType = {
    "void" => BuiltinType::Void,
    "int" => BuiltinType::Int,
}

// FuncFParams ::= FuncFParam {"," FuncFParam}
FuncFParams: FuncFParams = <params: Comma<FuncFParam>> => FuncFParams{ <> };

// FuncFParam  ::= BuiltinType IDENT ["[" "]" {"[" ConstExp "]"}];
FuncFParam: FuncFParam = {
    <btype: BuiltinType> <ident: Ident> => FuncFParam { btype, ident, shape: None },
    <btype: BuiltinType> <ident: Ident> "[" "]" <shape: ("[" <ConstExp> "]")*> => FuncFParam{ btype, ident, shape: Some(shape) },
}

// Block ::= "{" {BlockItem} "}";
Block: Block = "{" <block_items: BlockItem*> "}" => Block { <> };

// BlockItem ::= Decl | Stmt;
BlockItem: Box<BlockItem> = {
    Decl => Box::new(BlockItem::Decl( <> )),
    Stmt => Box::new(BlockItem::Stmt( <> )),
}

// Stmt ::= LVal "=" Exp ";"
//        | [Exp] ";"
//        | Block
//        | "if" "(" Exp ")" Stmt ["else" Stmt]
//        | "while" "(" Exp ")" Stmt
//        | "return" [Exp] ";";
Stmt: Box<Stmt> = {
    MatchedStmt => <>,
    OpenStmt => <>,
}

MatchedStmt: Box<Stmt> = {
    <LVal> "=" <Exp> ";" => Box::new(Stmt::Assign( <> )),
    <Exp?> ";" => Box::new(Stmt::Exp( <> )),
    "if" "(" <exp: Exp> ")" <s1: MatchedStmt> "else" <s2: MatchedStmt> => Box::new(Stmt::Condition(exp, s1, Some(s2))),
    <Block> => Box::new(Stmt::Block(Box::new( <> ))),
    "while" "(" <Exp> ")" <MatchedStmt> => Box::new(Stmt::While( <> )),
    "break" ";" => Box::new(Stmt::Break),
    "continue" ";" => Box::new(Stmt::Continue),
    "return" <exp: Exp?> ";" => Box::new(Stmt::Return( <> )), 
}

// Something that should have no trailing "else"
OpenStmt: Box<Stmt> = {
    "if" "(" <exp: Exp> ")" <s1: MatchedStmt> "else" <s2: OpenStmt> => Box::new(Stmt::Condition(exp, s1, Some(s2))),
    "if" "(" <exp: Exp> ")" <s1: Stmt> => Box::new(Stmt::Condition(exp, s1, None)),
    "while" "(" <Exp> ")" <OpenStmt> => Box::new(Stmt::While( <> )),
}

// Decl ::= ConstDecl | VarDecl;
Decl: Box<Decl> = {
    ConstDecl => Box::new(Decl::Const( <> )),
    VarDecl => Box::new(Decl::Var( <> )),
}
// VarDecl ::= BuiltinType VarDef {"," VarDef} ";";
VarDecl: Box<VarDecl> = <btype: BuiltinType> <var_defs: Comma<VarDef>> ";" => Box::new(VarDecl { <> });
// VarDef ::= IDENT ["[" ConstExp "]"] | IDENT ["[" ConstExp "]"] "=" InitVal;
VarDef: Box<VarDef> = {
    <ident: Ident> <shape: ("[" <ConstExp> "]")*> <init_val: ("=" <InitVal>)?> => Box::new(VarDef { <> }),
}
// InitVal ::= Exp | "{" [Exp {"," Exp}] "}";
InitVal: Box<InitVal> = {
    <Exp> => Box::new(InitVal::Single( <> )),
    "{" <exp: (<Comma<InitVal>>)?> "}" => Box::new(InitVal::Array( exp.unwrap_or(Vec::new()) )),
}

// ConstDecl ::= "const" BuiltinType ConstDef {"," ConstDef} ";";
ConstDecl: Box<ConstDecl> = "const" <btype: BuiltinType> <const_defs: Comma<ConstDef>> ";" => Box::new(ConstDecl { <> });

// ConstDef ::= IDENT {"[" ConstExp "]"} "=" ConstInitVal;
ConstDef: Box<ConstDef> = <ident: Ident> <shape: ("[" <ConstExp> "]")*> "=" <const_init_val: ConstInitVal> => Box::new(ConstDef { <> });
// ConstInitVal ::= ConstExp | "{" [ConstInitVal {"," ConstInitVal}] "}";
ConstInitVal: Box<ConstInitVal> = {
    <const_exp: ConstExp> => Box::new(ConstInitVal::Single( <> )),
    "{" <exps: (<Comma<ConstInitVal>>)?> "}" => Box::new(ConstInitVal::Array( exps.unwrap_or(Vec::new()) )),
}

// LVal ::= IDENT ["[" Exp "]"];
LVal: LVal = {
    <ident: Ident> <index: ("[" <Exp> "]")*> => LVal{ <> },
}

// ConstExp ::= Exp;
ConstExp: Box<ConstExp> = <exp: Exp> => Box::new(ConstExp { <> });

// Exp ::= LOrExp;
Exp: Box<Exp> = <lor_exp: LOrExp> => <>;
// PrimaryExp ::= "(" Exp ")" | LVal | Number;
PrimaryExp: Box<PrimaryExp> = {
    "(" <Exp> ")" => Box::new(PrimaryExp::Expression( <> )),
    LVal => Box::new(PrimaryExp::LVal( <> )),
    Number => Box::new(PrimaryExp::Number( <> )),
}
// UnaryExp ::= PrimaryExp | UnaryOp UnaryExp | IDENT "(" [FuncRParams] ")";
UnaryExp: Box<UnaryExp> = {
    PrimaryExp => Box::new(UnaryExp::Single( <> )),
    UnaryOp UnaryExp => Box::new(UnaryExp::Unary( <> )),
    <Ident> "(" <FuncRParams?> ")" => Box::new(UnaryExp::Call( <> )),
}
// FuncRParams ::= Exp {"," Exp}
FuncRParams: Box<FuncRParams> = <exps: Comma<Exp>> => Box::new(FuncRParams { <> });
// UnaryOp ::= "+" | "-" | "!";
UnaryOp: UnaryOp = {
    "+" => UnaryOp::Pos,
    "-" => UnaryOp::Neg,
    "!" => UnaryOp::Not,
}
// MulExp ::= UnaryExp | MulExp ("*" | "/" | "%") UnaryExp;
MulExp: Box<Exp> = {
    <UnaryExp> => Box::new(Exp::Single( <> )),
    <left: MulExp> "*" <right: UnaryExp> => Box::new(Exp::Binary(left, BinaryOperator::Mul, Box::new(Exp::Single(right)))),
    <left: MulExp> "/" <right: UnaryExp> => Box::new(Exp::Binary(left, BinaryOperator::Div, Box::new(Exp::Single(right)))),
    <left: MulExp> "%" <right: UnaryExp> => Box::new(Exp::Binary(left, BinaryOperator::Mod, Box::new(Exp::Single(right)))),
}
// AddExp ::= MulExp | AddExp ("+" | "-") MulExp;
AddExp: Box<Exp> = {
    <MulExp> => <>,
    <left: AddExp> "+" <right: MulExp> => Box::new(Exp::Binary(left, BinaryOperator::Add, right)),
    <left: AddExp> "-" <right: MulExp> => Box::new(Exp::Binary(left, BinaryOperator::Sub, right)),
}
// RelExp ::= AddExp | RelExp ("<" | ">" | "<=" | ">=") AddExp;
RelExp: Box<Exp> = {
    <AddExp> => <>,
    <left: RelExp> "<" <right: AddExp> => Box::new(Exp::Binary(left, BinaryOperator::Lt, right)),
    <left: RelExp> ">" <right: AddExp> => Box::new(Exp::Binary(left, BinaryOperator::Gt, right)),
    <left: RelExp> "<=" <right: AddExp> => Box::new(Exp::Binary(left, BinaryOperator::Le, right)),
    <left: RelExp> ">=" <right: AddExp> => Box::new(Exp::Binary(left, BinaryOperator::Ge, right)),
}
// EqExp ::= RelExp | EqExp ("==" | "!=") RelExp;
EqExp: Box<Exp> = {
    <RelExp> => <>,
    <left: EqExp> "==" <right: RelExp> => Box::new(Exp::Binary(left, BinaryOperator::Eq, right)),
    <left: EqExp> "!=" <right: RelExp> => Box::new(Exp::Binary(left, BinaryOperator::NotEq, right)),
}
// LAndExp ::= EqExp | LAndExp "&&" EqExp;
LAndExp: Box<Exp> = {
    <EqExp> => <>,
    <left: LAndExp> "&&" <right: EqExp> => Box::new(Exp::Binary(left, BinaryOperator::And, right)),
}
// LOrExp ::= LAndExp | LOrExp "||" LAndExp;
LOrExp: Box<Exp> = {
    <LAndExp> => <>,
    <left: LOrExp> "||" <right: LAndExp> => Box::new(Exp::Binary(left, BinaryOperator::Or, right)),
}

Number: i32 = <num: IntConst> => <>;

Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();

IntConst: i32 = {
    r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
    r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
    r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
}
